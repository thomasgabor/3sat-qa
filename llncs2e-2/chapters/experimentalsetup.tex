\section{Experimental Setup}
\label{sec:exp-setup}

Quantum annealing is an optimization process that can be implemented in hardware. It is built upon the adiabatic theorem that provides conditions under which an initial ground-state configuration of a system evolves to the ground state of another configuration that minimizes a specific user-defined energy function~\cite{mcgeoch2014adiabatic}. As in the real world the required conditions for the theorem can only be approximated, the results of quantum annealing are usually not deterministically optimal but show a probabilistic distribution, ideally covering the desired optimal value as well.

D-Wave's quantum annealer is the first commercial machine to implement quantum annealing. Its interface is built on two equivalent mathematical models for optimization problems called Ising and QUBO, the latter of which will be used for the work of this paper. Quadratic Unconstrained Binary Optimization (QUBO) problems can be formulated as a quadratic matrix $Q_{ij}$. Quantum annealing then searches for a vector $x \in \{0,1\}^n$ so that $\sum_i \sum_{j < i} Q_{ij} x_i x_j + \sum_i Q_i x_i$ is minimal. The promise of quantum annealing is that---using quantum effects---specialized hardware architectures are able to solve these optimization problems much faster than classical computers in the future.

The main goal of this paper is to analyze the inherently probabilistic distribution of return values generated by quantum annealing when trying to solve hard optimization problems. We choose to demonstrate such an analysis on 3SAT because it is the canonical problem of the class NP, which is a prime target for research on performance improvements via quantum technology with respect to classical computers~\cite{mcgeoch2013experimental,lucas2014ising}.

\subsection{Defining 3SAT as a QUBO}
3SAT is usually not formulated as an optimization problem (see Section~\ref{sec:preliminaries}), or defined by an equivalent QUBO problem,
as is required by the annealer. Thus, we require a (polynomial-time) translation of any 3SAT instance into a QUBO so that the solutions generated by the quantum annealer can be translated back to solutions of the initial 3SAT instance.

Following~\cite{choi2010adiabatic,choi2011different}, we translate 3SAT into the Weighted Maximum Independent Set (WMIS) problem (which we covered in Section~\ref{sec:preliminaries}), and then translate the WMIS instance into a QUBO (we find it convenient to specify the polynomial coefficients in matrix form). We omit the details of the process and instead refer to \emph{op.~cit.{}} and Ref.~\cite{lucas2014ising}. However, we shall briefly discuss the implications of the translation process.

A 3SAT instance, that is, a formula with $m$ clauses for $n$ variables,
requires a QUBO matrix of size $3m \times 3m$ with the solution vector $x \in \{0,1\}^{3m}$. The solution can be thought of as using a qubit for each literal in the initial formula and thus consisting of a triplet of qubits for each 3SAT clause. This usually means that we have much more qubits than variables in the formula. Nonetheless, a QUBO solution is mapped to a value assignment for the variables in the 3SAT formula. Thus, when running successfully, the quantum annealer will output a satisfying assignment for a given 3SAT formula. We can check if the assignment really is correct (i.e., each variable has a value assigned and the whole formula reduces to $\textit{True}$) using few instructions of classical computation. Obviously, if among several experimental runs the quantum annealer does return just one correct assignment, the corresponding 3SAT formula is satisfiable. If the quantum annealer only returns incorrect assignments, we will regard the formula as unsatisfiable (although the prove of that is only probabilistic).

There are some aspects to note about how the QUBO solution vectors are mapped to variable assignments. Given a QUBO solution vector $(x_i)_{0 \leq i \leq 3m-1}$ for a 3SAT formula with literals $(l_i)_{0 \leq i \leq 3m-1}$, a variable $v$ is assigned the value $\textit{True}$ if it occurs in a literal $l_i = v$ and $x_i = 1$. Likewise, a variable $v$ is assigned the value $\textit{False}$ if it occurs in a literal $l_i = \lnot v$ and $x_i = 1$. It is important to note that $x_i = 0$ has \emph{no implication} on the value of the variable in $l_i$.

Intuitively, we can interpret $x_i = 1$ to mean ``use the value of $l_i$ to prove the satisfaction of clause $c_{(i \mod 3)}$''. From our QUBO optimization, we expect to find one (and only one) suitable $l_i$ for every clause in the 3SAT formula.\footnote{This intuition matches the concept of constructivism in logic and mathematics. We are not only looking for the correct answer, but are looking for a correct and complete proof of an answer, giving us a single argument for each part of the formula.}

This is important as it opens up a wide range of different QUBO solutions which may just encode the exact same variable assignment at the 3SAT level. However, it also means that seemingly suboptimal QUBO solutions may encode correct 3SAT assignments. For example, consider the (a little redundant) 3SAT formula $(v_0 \lor v_1 \lor v_2) \land (v_0 \lor v_1 \lor v_2)$: The QUBO solution $x = 100001$ would imply the assignment of $v_0 = \textit{True}$ and $v_2 = \textit{True}$, which indeed is theoretically sufficient to prove the formula satisfiable. The exact same assignment would be implied by $x = 001100$. However, note that none of these imply a full assignment of every variable in the 3SAT instance since none say anything about the value of $v_1$. Still, we can trivially set $v_1$ to any arbitrary value and end up with a correct assignment. Also note that while the QUBO is built in such a way to opt for one single value $1$ per triplet in the bit string, even bitstrings violating this property can encode correct solution. In our example, the suboptimal QUBO solution $x=100000$ still encodes all necessary information to prove satisfiability.

\subsection{Evaluating Postprocessing}

As can be seen from the last example, postprocessing is an integral part of solving problems with quantum annealing. As discussed earlier in this section, we consider a QUBO solution correct, if it not only matches the expected structure for minimizing the QUBO energy function, but instead iff it directly implies a correct assignment in the definition given above. Thus, while the expected structure for QUBO optimizes $x$ so that the amount bits $x_i$ assigned $1$ equals the amount of clauses $m$, we also consider less full answers correct.

On top of that, there are solutions that cannot be mapped to an assignment immediately, but still with almost no effort. We want to regard these as well and implemented a postprocessing step we call \emph{logical postprocessing}. It is applied whenever none of the qubits corresponding to a single clause $c_k$ are set to $1$ by the quantum annealer and the respective QUBO solution is not already correct. In that case, we iterate through all literals $l_i$ in that clause $c_k$ and check if we could set $x_i = 1$ without contradicting any other assignment made within $x$. If we find such an $l_i$, we set $x_i = 1$ and return the altered bitstring $x$.

The software platform provided by D-Wave to use the quantum annealer already offers integrated postprocessing methods as well, which we will also empirically show to be more powerful than logical postprocessing in the following Section~\ref{sec:evaluation}. Again, for greater detail we refer to the D-Wave documentation on that matter~\cite{dwavepostprocessing}. At a glance, the employed postprocessing method splits the QUBO matrix into several subproblems, tries to optimize these locally, and then integrates that local solution into the complete solution if it yields an improvement. We call this method \emph{D-Wave postprocessing}.

To evaluate the solution quality regarding 3SAT, we employ both methods. The goal is to assess the expected quality on a 3SAT-to-3SAT level, that is, we measure how well we can solve the given 3SAT instance and regard the translation to and from QUBO as a mere technical problem that is not of
interest for this paper.

%$c_k = (l_{3k} \lor l_{3k+1} \lor l_{3k+2})$ 


%
%
%\todo{0.5 SAT via WMIS on QA}
%\todo{1 Experimental Setup}
%
%
%\subsection{Optimierungs-Postprocessing des D-Wave}
%Nachdem ein Problem via Quantumannealing gelöst wurde, stellt der D-Wave Quantenannealer zusätzlich die Möglichkeit verschiedener Arten von Postprocessing bereit. In dieser Arbeit wird ausschließlich das Optimierungs-Postprocessing des D-Wave benutzt.\\\\Das Ziel des Optimierungs-Postprocessings ist es, eine Menge an Lösungen zu erhalten, die auf einem bestimmten Graphen $\mathcal{G}$ die geringste Energie aufweisen. Um dies zu erreichen, wird ein gegebener Graph $\mathcal{G}$ durch eine heuristische Methode (vgl. \cite{markowitz1957elimination}) in mehrere Teilgraphen zerlegt. Danach wird die bereits von der QPU erhaltene Lösung so verändert, dass für jeden Subgraphen eine lokal optimale Lösung entsteht. Für eine tiefergehende Darstellung des Postprocessings auf dem D-Wave sei an dieser Stelle auf die D-Wave Dokumentation zu diesem Thema (siehe \cite{dwavepostprocessing}) verwiesen, in welcher auch der hier dargestellte grobe Überblick über das Optimierungs-Postprocessing gefunden werden kann.
%%%%%%%%%%%%% LOGISCHES POSTPROCESSING %%%%%%%%%%%%
%\subsection{Logisches Postprocessing}
%Zusätzlich zum D-Wave Optimierungs-Postprocessing wird in dieser Arbeit ein vom Autor dieser Arbeit erdachtes logisches Postprocessing verwendet, um die ursprünglichen Ergebnisse der QPU weiter zu verbessern. Bei diesem logischen Postprocessing, wird eine von der QPU erhaltene Lösung, welche ein Spinarray der Länge 3\emph{m} ist, wobei \emph{m} die Anzahl der Klauseln in einem 3SAT-Problem darstellt, zurück auf eine Variablenbelegung der logischen Variablen des 3SAT-Problems abgebildet. Danach wird überprüft ob es nicht erfüllte Klauseln gibt. Ist dies der Fall, so wird für jede Variable einer nicht erfüllten Klausel überprüft, ob deren Negation bereits die Belegung \emph{wahr} erhalten hat. Ist dies nicht der Fall, so kann der betrachteten Variable der Wahrheitswert \emph{wahr} zugewiesen werden. In diesem Fall werden weitere Variablen dieser Klausel nicht mehr angesehen und es wird direkt mit der nächsten nicht erfüllten Klausel fortgefahren.
%
