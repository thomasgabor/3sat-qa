\section{Experimental Setup}
\label{sec:exp-setup}

Quantum annealing is an optimization process that can be implemented in hardware. It is built on the adiabatic theorem which in theory guarantees the evolution of an initial configuration of the system to a configuration minimizing a specific user-defined energy function \cite{mcgeoch2014adiabatic}. As in the real world the required conditions for the theorem can only be approximated, the results of quantum annealing are usually not exact but show a probabilistic distribution, ideally covering the desired optimal value as well.

D-Wave's quantum annealer is the first commercial machine to implement quantum annealing. Its interface is built on two equivalent mathematical models for optimization problems called Ising and QUBO, the latter of which will be used for the work of this paper. Quadratic Unconstrained Binary Optimization (QUBO) problems can be formulated as a quadratic matrix $Q_{ij}$. Quantum annealing then searches for a vector $x \in \{0,1\}^n$ so that $\sum_i \sum_{j < i} Q_{ij} x_i x_j + \sum_i Q_i x_i$ is minimal. The promise of quantum annealing is that--using quantum effects--specialized hardware architectures are able to solve these optimization problems much faster than classical computers in the future.

The main goal of this paper is to analyze the inherently probabilistic distribution of return values generated by quantum annealing when trying to solve hard optimization problems. We choose to demonstrate such an analysis on 3SAT because it is the canonical problem of the class NP, which is a prime target for research on performance improvements via quantum technology with respect to classical computers \cite{}.

\subsection{Defining 3SAT as a QUBO matrix}

However, 3SAT is not even usually formulated as an optimization problem (see Section~\ref{sec:preliminaries}) or a QUBO matrix specifically. Thus, we require a (polynomial-time) translation of any 3SAT instance into a QUBO matrix so that the solutions generated by the quantum annealer can be translated back to solution of the initial 3SAT instance.

For this purpose, we use the approach given in \cite{choi2010adiabatic,choi2011different} by translating 3SAT into the Weak Maximum Independent Set (WMIS) problem first and then translating the WMIS instance into a QUBO matrix. We omit the details of this process and instead refer to literature \cite{choi2010adiabatic,choi2011different,lucas2014ising}. However, we shall shortly discuss the implications of that translation process.

In the end for a 3SAT instance, i.e., a formula, with $m$ clauses for $n$ variables we end up with a QUBO matrix of size $3m \times 3m$ with the solution vector $x \in \{0,1\}^{3m}$. The solution can be thought of as using a qubit for each literal in the initial formula and thus consisting of a triplet of qubits for each 3SAT clause. This usually means that we have much more qubits than variables in the formula. Nonetheless, a QUBO solution is mapped to a value assignment for the variables in the 3SAT formula. Thus, when running successfully, the quantum annealer will output a satisfying assignment for a given 3SAT formula. We can check if the assignment really is correct (i.e., each variable has a value assigned and the whole formula reduces to $\textit{True}$) using few instructions of classical computation. Obviously, if among several experimental runs the quantum annealer does return a correct assignment, the corresponding 3SAT formula is satisfiable. If the quantum annealer only return incorrect assignments, we will regard the formula as unsatisfiable (although the prove of that is only probabilistic).

There are some aspects to note about how the QUBO solution vectors are mapped to variable assignments. Given a QUBO solution vector $(x_i)_{0 \leq i \leq 3m-1}$ for a 3SAT formula with literals $(l_i)_{0 \leq i \leq 3m-1}$, a variable $v$ is assigned the value $\textit{True}$ if it occurs in a literal $l_i = v$ and $x_i = 1$. Likewise, a variable $v$ is assigned the value $\textit{False}$ if it occurs in a literal $l_i = \lnot v$ and $x_i = 1$. It is important to note that $x_i = 0$ has \emph{no implication} on the value of the variable in $l_i$.

Intuitively, we can interpret $x_i = 1$ to mean ``use the value of $l_i$ to prove the satisfaction of clause $c_{(i \mod 3)}$''. From our QUBO optimization, we expect to find one (and only one) suitable $l_i$ for every clause in the 3SAT formula.\footnote{Perhaps interestingly, this intuition matches the concept of constructivism in logic and mathematics. We are not only looking for the correct answer, but are looking for a correct and complete proof of an answer, giving us a single argument for each part of the formula.}

This is important as it opens up a wide range of different QUBO solutions which may just encode the exact same variable assignment at the 3SAT level. However, it also means that seemingly suboptimal QUBO solutions may encode correct 3SAT assignments. For example, consider the (a bit redundant) 3SAT formula $(v_0 \lor v_1 \lor v_2) \land (v_0 \lor v_1 \lor v_2)$: The QUBO solution $x = 100001$ would imply the assignment of $v_0 = \textit{True}$ and $v_2 = \textit{True}$, which indeed is theoretically sufficient to prove the formula satisfiable. The exact same assignment would be implied by $x = 001100$. However, note that none of these imply a full assignment of every variable in the 3SAT instance since none say anything about the value of $v_1$. Still, we can trivially set $v_1$ to any arbitrary value and end up with a correct assignment. Also not that while the QUBO is built in such a way to opt for one single value $1$ per triplet in the bitstring, even bitstrings violating this property can encode correct solution. In our example, the suboptimal QUBO solution $x=100000$ still encodes all necessary information to prove satisfiability.

\subsection{Evaluating Postprocessing}

As can be seen from the last example, postprocessing is an integral part of solving problem with quantum annealing. As discussed in the previous section, we consider a QUBO solution correct not only if its matches the expected structure for minimizing the QUBO energy function but instead iff it directly implies a correct assignment in the definition given above. Thus, where the expected structure for QUBO optimizes so that the amount bits assigned $1$ equals the amount of clauses $m$, we also consider less full answers correct.

On top of that, there are solutions that cannot be mapped to an assignment immediately, but still with next to no effort. We want to regard these as well and implemented a postprocessing step we call \emph{logical postprocessing}. It is applied whenever none of the qubits corresponding to a single clause $c_k$ are set to $1$ by the quantum annealer and the respective QUBO solution is not already correct. In that case, we iterate through all literals $l_i$ in that clause $c_k$ and check if we could set $x_i = 1$ without contradicting any other assignment made within $x$. If we find such an $l_i$, we set $x_i = 1$ and return the altered bitstring $x$.

The software platform provided by D-Wave to use the quantum annealer already offers integrated postprocessing methods as well, which we will also empirically prove to be more powerful than logical postprocessing in the following Section~\ref{sec:evaluation}. Again, for greater detail we refer to the D-Wave documentation on that matter \cite{dwavepostprocessing}. At a glance, the employed postprocessing method splits the QUBO matrix into several subproblems, tries to optimize these locally, and then integrates that local solution into the complete solution if it yields an improvement. We call this method \emph{D-Wave postprocessing}.

In order to evaluate the solution quality regarding 3SAT we employ both methods. The goal is to assess the expected quality on a 3SAT-to-3SAT level, i.e., we measure how well we can solve the given 3SAT instance and regard the translation to and from QUBO as a mere tool chain but not that interesting on its own for the scope of this paper.

%$c_k = (l_{3k} \lor l_{3k+1} \lor l_{3k+2})$ 


%
%
%\todo{0.5 SAT via WMIS on QA}
%\todo{1 Experimental Setup}
%
%
%\subsection{Optimierungs-Postprocessing des D-Wave}
%Nachdem ein Problem via Quantumannealing gelöst wurde, stellt der D-Wave Quantenannealer zusätzlich die Möglichkeit verschiedener Arten von Postprocessing bereit. In dieser Arbeit wird ausschließlich das Optimierungs-Postprocessing des D-Wave benutzt.\\\\Das Ziel des Optimierungs-Postprocessings ist es, eine Menge an Lösungen zu erhalten, die auf einem bestimmten Graphen $\mathcal{G}$ die geringste Energie aufweisen. Um dies zu erreichen, wird ein gegebener Graph $\mathcal{G}$ durch eine heuristische Methode (vgl. \cite{markowitz1957elimination}) in mehrere Teilgraphen zerlegt. Danach wird die bereits von der QPU erhaltene Lösung so verändert, dass für jeden Subgraphen eine lokal optimale Lösung entsteht. Für eine tiefergehende Darstellung des Postprocessings auf dem D-Wave sei an dieser Stelle auf die D-Wave Dokumentation zu diesem Thema (siehe \cite{dwavepostprocessing}) verwiesen, in welcher auch der hier dargestellte grobe Überblick über das Optimierungs-Postprocessing gefunden werden kann.
%%%%%%%%%%%%% LOGISCHES POSTPROCESSING %%%%%%%%%%%%
%\subsection{Logisches Postprocessing}
%Zusätzlich zum D-Wave Optimierungs-Postprocessing wird in dieser Arbeit ein vom Autor dieser Arbeit erdachtes logisches Postprocessing verwendet, um die ursprünglichen Ergebnisse der QPU weiter zu verbessern. Bei diesem logischen Postprocessing, wird eine von der QPU erhaltene Lösung, welche ein Spinarray der Länge 3\emph{m} ist, wobei \emph{m} die Anzahl der Klauseln in einem 3SAT-Problem darstellt, zurück auf eine Variablenbelegung der logischen Variablen des 3SAT-Problems abgebildet. Danach wird überprüft ob es nicht erfüllte Klauseln gibt. Ist dies der Fall, so wird für jede Variable einer nicht erfüllten Klausel überprüft, ob deren Negation bereits die Belegung \emph{wahr} erhalten hat. Ist dies nicht der Fall, so kann der betrachteten Variable der Wahrheitswert \emph{wahr} zugewiesen werden. In diesem Fall werden weitere Variablen dieser Klausel nicht mehr angesehen und es wird direkt mit der nächsten nicht erfüllten Klausel fortgefahren.
%
